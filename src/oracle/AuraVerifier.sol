// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IAuraVerifier} from "../interfaces/IAuraVerifier.sol";

/// @title AuraVerifier - AI Provenance verification for micro-event integrity
/// @notice Verifies that micro-event outcomes are generated by registered AI models.
///         Each attestation proves: which model, what data, and confidence level.
/// @dev Attestations verified via ECDSA signature from authorized Aura reporters.
contract AuraVerifier is IAuraVerifier {
    // ===================== STORAGE =====================

    mapping(bytes32 => string) public modelRegistry;
    mapping(bytes32 => bool) private _registeredModels;
    mapping(address => bool) public authorizedReporters;
    mapping(bytes32 => bool) public verifiedAttestations;

    uint64 public override minConfidence = 7000; // 70% in basis points
    address public owner;

    // ===================== CONSTRUCTOR =====================

    constructor() {
        owner = msg.sender;
    }

    // ===================== VERIFICATION =====================

    /// @notice Verify an AI provenance attestation
    function verifyAttestation(
        bytes32 modelHash,
        bytes32 dataHash,
        uint64 confidence,
        bytes calldata signature
    ) external returns (bytes32 attestationHash) {
        require(_registeredModels[modelHash], "Aura: model not registered");
        require(confidence >= minConfidence, "Aura: confidence too low");
        require(signature.length == 65, "Aura: invalid signature length");

        attestationHash = keccak256(abi.encodePacked(modelHash, dataHash, confidence, block.timestamp));

        bytes32 ethSignedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", attestationHash)
        );

        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);
        address signer = ecrecover(ethSignedHash, v, r, s);

        require(signer != address(0), "Aura: invalid signature");
        require(authorizedReporters[signer], "Aura: unauthorized reporter");

        verifiedAttestations[attestationHash] = true;
        emit AttestationVerified(attestationHash, signer);
    }

    function isModelRegistered(bytes32 modelHash) external view returns (bool) {
        return _registeredModels[modelHash];
    }

    // ===================== ADMIN =====================

    function registerModel(bytes32 modelHash, string calldata modelUri) external {
        require(msg.sender == owner, "Aura: not owner");
        _registeredModels[modelHash] = true;
        modelRegistry[modelHash] = modelUri;
        emit ModelRegistered(modelHash, modelUri);
    }

    function setReporter(address reporter, bool authorized) external {
        require(msg.sender == owner, "Aura: not owner");
        authorizedReporters[reporter] = authorized;
    }

    function setMinConfidence(uint64 _minConfidence) external {
        require(msg.sender == owner, "Aura: not owner");
        require(_minConfidence <= 10000, "Aura: max 10000 bps");
        minConfidence = _minConfidence;
    }

    // ===================== INTERNAL =====================

    function _splitSignature(bytes calldata sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {
        r = bytes32(sig[0:32]);
        s = bytes32(sig[32:64]);
        v = uint8(bytes1(sig[64:65]));
    }
}
